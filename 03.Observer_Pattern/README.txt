# Observer Pattern
[관찰자 패턴]
- 객체 사이에 일 대 다의 의존 관계를 정의해두어, 어떤 객체의 상태가 변할 때 그 객체에 의존성을 가진 다른 객체들이 그 변화를 통지 받고 자동으로 업데이트 될 수 있게 한다.

--------------------------------------------------------------------------------------------------------------------

(구현)
- 대상(Subject) 객체는 옵저버들을 관리하고 상태 변경을 감지하고, 옵저버들에게 알림을 보낸다.
- 옵저버 객체는 대상의 상태 변경을 감지하고 처리한다.
- 대상과 옵저버 클래스를 추상화하여 각각의 기본 동작을 정의하고 구체적인 클래스를 구현한다.
--------------------------------------------------------------------------------------------------------------------

<장점>
- OCP(개방-폐쇄 원칙), 기존 코드를 변경하지 않고 새로운 주제나 옵저버를 추가할 수 있다.
- 대상과 옵저버의 관계가 느슨해서 대상이 변경되어도 옵저버에 영향을 주지 않는다. (느슨한 결함, Loose Coupling)
- 런타임에 새로운 옵저버를 추가하거나 기존 옵저버를 제거할 수 있다. (확장성, Scalability)
- 대상과 옵저버는 독립적인 모듈로 구성된다. (Modularity)
- 대상은 옵저버가 특정 인터페이스를 구현하는 것만 알고, 옵저버를 추가한다고 해서 대상을 변경할 필요가 없다.

<단점>
 - 대상 객체의 상태가 변경될 때마다 모든 옵저버에게 알림을 보내야해서 처리속도가 떨어질 수 있다.
 - 대상과 옵저버 간의 순환참조 위험이 있다.

--------------------------------------------------------------------------------------------------------------------

(예제)
- 업적 달성
업적은 여러 플레이 요소에서 발생시킬 수 있는데 커플링되지 않고 업적 코드가 동작하게 할 때 사용할 수 있다. 

옵저버 클래스는 가상 소멸자와 알림을 주는 순수 가상함수로 구성된다.
그리고 이 옵저버 클래스를 상속하면 어떤 클래스든 관찰자가 될 수 있다.
알림 메서드는 관찰당하는 객체가 호출한다. 이 객체를 대상(Subject)라 한다.

Subject에게는 두 가지 임무가 있는데 그 중 하나는 알림을 기다리는 관찰자 목록을 들고 있는 것이다.
이 관찰자 목록은 밖에서도 변경 가능하도록 public으로 열어둔다는 것이 중요하다.
이를 통해 누가 알림을 받을 것인지 제어할 수 있다. Subject는 관찰자와 상호작용하지만, 서로 커플링되어있지 않다. 이것이 관찰자 패턴의 장점이다.
관찰자를 여러 개 등록할 수 있게하면 관찰자들이 각자 독립적으로 다뤄지는 것을 보장할 수 있다.

=> 1번 코드 참고
--------------------------------------------------------------------------------------------------------------------

<관찰자 패턴을 사용하면 느려지는가?>
관찰자 패턴은 정적 호출보다는 약간 느리지만, 큰 문제가 되지는 않는다.
게다가 관찰자 패턴은 성능에 민감하지 않은 곳에 가장 잘 맞기 때문에 동적 디스패치를 써도 크게 상관없다.
인터페이스를 통해 동기적으로 메서드를 간접 호출할 뿐 메시징용 객체를 할당하지도 않고, 큐잉도 하지 않는다.
(동적 디스패치: 인스턴스의 자료형을 모르는 경우로 정적 디스패치와는 다르게 올바를 함수를 호출할 방법을 찾아야한다. 따라서 포인터 추적으로 인해 정적 디스패치보다 조금 느릴 수 있다.)

<그렇다면 빠르다고 할 수 있는가?>
주의할 점은 관찰자 패턴이 동기적이라는 점이다. 
Subject가 관찰자 메서드를 직접 호출하기 때문에 모든 관찰자가 알림 메서드를 반환하기 전에는 다음 작업을 진행할 수 없다. 이 때문에 관찰자 중 하나라도 느리면 대상이 블록될 수도 있다.
이벤트에 동기적으로 반응한다면 최대한 빨리 작업을 끝내고 제어권을 다시 넘겨줘서 UI가 멈추지 않도록 해야한다.
만약 오래 걸리는 작업이 있다면 다른 스레드에 넘기거나 작업 큐를 활용해야한다.
관찰자는 특히 멀티 스레드, lock과 함께 사용할 때 더 조심해야한다.
어떤 관찰자가 Subject의 lock을 물고 있다면 게임 전체가 교착상태에 빠질 수 있다.
엔진에서 멀티 스레드를 많이 사용하고 있다면 이벤트 큐를 이용해 비동기적으로 상호작용하는 것이 더 좋을 수 있다.

--------------------------------------------------------------------------------------------------------------------

<동적할당을 너무 많이하는 것 같은데?>
1번 예제에서는 간단하게 만들기 위해 고정 배열을 사용했으나 실제 게임 코드 였다면 관찰자를 추가, 삭제될 때 크기가 알아서 변하는 동적 할당을 사용했을 것이다.
그러나 알림을 보낼 때는 메서드를 호출할 뿐 동적할당은 젆 하지 않는다. 
실행시 처음 관찰자를 등록해놓은 뒤 건드리지 않는다면 메모리 할당은 거의 일어나지 않는다.

<그래도 동적할당 때문에 찜찜하다면>
동적할당 없이 관찰자를 등록, 해제하는 방법을 살펴보면,
1번 예제의 코드는 Subject가 자신에게 등록된 Observer의 포인터 목록을 들고 있다.
Observer 클래스 자신은 이들 포인터 목록을 참조하지 않으며, 그저 순수 가상 인터페이스이다.
그러나 Observer에 상태를 조금 추가하면 관찰자가 스스로를 엮게 만ㄷ르어 동적할당 문제를 해결할 수 있다.
(Subject 클래스에 배열 대신 관찰자 연결 리스트의 첫번째 노드를 가리키는 head 포인터를 두고, 
Observer에 연결 리스트는 다음 관찰자를 가리키는 포인터를 추가하고, Subject를 friend 클래스로 정의한다.)
관찰자 객체가 연결 리스트의 노드가 되는 것이다. 
새로운 관찰자를 연결 리스트에 추가하기만 하면 Subject에 등록할 수 있다.
이로써 동적 메모리를 할당하지 않고도 얼마든지 관찰자를 등록할 수 있으며 추가, 삭제는 단순 배열로 만든 것과 다름없이 빠르다.

다만, 관찰자 객체 그자체를 리스트 노드로 활용하기 때문에 관찰자는 한 번에 한 Subject만 관찰할 수 있다

--------------------------------------------------------------------------------------------------------------------

<리스트 노드 풀>
한 Subject에 여러 관찰자가 붙는 경우의 연결 리스트 노드는 관찰자 객체가 아니다.
대신 따로 간단한 노드를 만들어 관찰자와 다음 노드를 포인터로 가리키게 한다.
같은 관찰자를 여러 노드에서 가리킬 수 있다는 것은 같은 관찰자를 동시에 여러 대상에 추가할 수 있다는 뜻이다.
이로 인해 다시 여러 대상을 한 번에 관찰할 수 있게 된다.
모든 노드가 같은 자료형이므로 객체 풀에 미리 할당하면 동적할당도 피할 수 있다.

--------------------------------------------------------------------------------------------------------------------

<Subject와 관찰자 제거>
관찰자를 부주의하게 삭제하다 보면 대상에 있는 포인터가 이미 삭제된 객체를 가리킬 수 있다.
해제된 메모리를 가리키는 dangling pointer에 알림을 보내게되는 것이다.

Subject가 죽었을 경우 Subject가 죽기 직전에 마지막으로 사망알림을 보내면 되고, 관찰자는 필요한 작업을 알아서 하면 된다.

Subject가 관찰자를 포잍너로 알고 있기 때문에 관찰자는 제거하기 더 어렵다.
관찰자를 제거하는 가장 쉬운 방법은 관찰자가 삭제될 때 스스로를 등록 취소하는 것이다.
관찰자는 보통 관찰 중인 대상을 알고 있으므로 소멸자에서 대상의 removeObserver()만 호출하면 된다.
다른 방법으로는 관찰자가 제거될 때 자동으로 모든 대상으로부터 등록 취소하게 만드는 것이다.
상위 관찰자 클래스에 등록 취소 코드를 구현해두면 이를 상속받는 모든 클래스는 등록 취소를 고민할 필요가 없다.
그러나 이 두 방법은 관찰자가 관찰중인 Subject 목록을 관리해야하기 때문에 상호참조가 생겨 복잡성이 늘어나는 단점이 있다.

<GC가 해주지 않을까?>
가비지 컬렉터(GC)를 사용하면 명시적으로 삭제하지 않아도 되는데 위의 문제를 고민할 필요가 있을까?

캐릭터를 관찰하던 UI창은 알림을 받아 체력바를 갱신한다. 
이때 관찰자를 등록 취소하지 않는다면 UI가 더이상 보이지 않지만 캐릭터의 관찰자 목록에서 여전히 UI를 참조하기 있으므로 GC가 수거해 가지 않는다.
상태창을 열 때마다 상태창 인스턴스를 새로 만들어 추가하므로 관찰자 목록은 점점 커진다.
캐릭터는 이 모든 상태창 객체에 알림을 보낸다.
그렇게 되면 눈에 보이지도 않는 UI요소를 업데이트 하느라 CPU 클럭을 낭비한다.

이는 사라진 리스너 문제(lapsed listener problem)라는 알림 시스템에서 굉장히 자주 일어나는 문제이다. 
대상이 리스너 레퍼런스를 유지하기 때문에, 메모리에 남아있는 좀비 UI가 생기므로 등록 취소는 주의해야 한다.