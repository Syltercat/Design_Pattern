# Flyweight Pattern
[경량 패턴]
- 공유를 통해 많은 수의 소립 객체들을 효과적으로 지원한다.
- 어떤 객체의 수가 너무 많아서 가볍게 만들고자할 때 사용한다.

--------------------------------------------------------------------------------------------------------------------
예제)
1) 숲에 나무가 많아도 대부분 비슷해 보인다. 따라서 모든 나무를 같은 메시와 텍스처로 표현할 수 있다.
  즉, 나무 객체에 들어있는 데이터가 인스턴스별로 다르지 않다는 의미이다.
2) 모든 나무가 다 같이 사용하는 데이터(메시, 텍스처)를 뽑아 새로운 클래스인 TreeModel을 모은다.
3) Tree 클래스를 멤버 변수로 갖는 클래스 Tree를 만든다. 
   이때 게임 내에서 같은 메시와 텍스처를 여러번 메모리에 올릴 이유가 없으므로 나무 객체는 하나만 존재하면 된다.
4) 각 나무 인스턴스는 공유 객체인 TreeModel을 참조하면 된다. Tree 클래스에는 인스턴스별로 다른 상태 값만 남겨둔다.

=> 1번 코드 참고
--------------------------------------------------------------------------------------------------------------------

경량 패턴은 객체 데이터를 두 종류로 나눈다.
[1] 고유 상태(intrinsic state): 모든 객체의 데이터 값이 같아서 공유할 수 있는 데이터, 책에서는 자유 문맥 상태라고 부른다. (context-free) => 나무의 형태나 텍스처가 이에 해당한다.
[2] 외부 상태(extrinxic state): 인스턴스별로 값이 다른 데이터 => 나무의 위치, 크기, 색등이 이에 해당한다.

경량 패턴은 한 개의 고유 상태를 다른 객체에서 공유하게 만들어 메모리 사용량을 줄인다.

공유 객체가 명확하지 않은 경우 경량 패턴은 잘 드러나 보이지 않는다. 이런 경우 하나의 객체가 여러 곳에 동시에 존재하는 것처럼 보인다.
=> 2번 코드 참고
--------------------------------------------------------------------------------------------------------------------

열거형을 선언해 수많은 다중 선택문을 만들 생각이라면 경량패턴을 먼저 고려해보자.